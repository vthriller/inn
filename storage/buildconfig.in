#! /usr/bin/perl

##  $Id$
##
##  Generate linkage code and makefiles for storage and overview methods.
##
##  Goes through all subdirectories of the current directory and finds
##  directories that are either storage methods or overview methods.  Builds
##  methods.[ch] and ovmethods.[ch] as well as makefile stubs.

require 5.003;

use strict;
use vars qw(@OVERVIEW @STORAGE);

# Storage API functions.
@STORAGE = qw(init store retrieve next freearticle cancel ctl flushcacheddata
              printfiles shutdown);

# Overview API functions.
@OVERVIEW = qw(open groupstats groupadd groupdel add cancel opensearch search
               closesearch getartinfo expiregroup ctl close);

# Used to make heredocs more readable.
sub unquote { my ($string) = @_; $string =~ s/^:( {0,7}|\t)//gm; $string }

# Parse a method.config file for a storage method, putting information about
# that storage method into the given hash ref.
sub parse_config {
    my ($dir, $file, $config) = @_;
    $$config{progdirs} ||= [];
    local $_;
    open (CONFIG, "$dir/$file") or die "Can't open $dir/$file: $!\n";
    while (<CONFIG>) {
        s/^\s+//;
        s/\s+$//;
        if (/^name\s*=\s*(\S+)$/) {
            my $method = $1;
            die "$dir/$file: $method has already been defined\n"
                if (defined $$config{method}{$method});
            $$config{method}{$method} = $dir;
        } elsif (/^number\s*=\s*(\d+)$/) {
            my $number = $1;
            if (defined $$config{number}{$number}) {
                die "$dir/$file: method number $number was already "
                    . "allocated in $$config{number}{$number}\n";
            }
            $$config{number}{$dir} = $number;
        } elsif (/^modules\s*=\s*(.*)/) {
            my $objects = $1;
            my @objects = split (' ', $objects);
            $$config{objects} ||= [];
            push (@{ $$config{objects} }, map { "$dir/$_" } @objects);
        } elsif (/^programs\s*=\s*(.*)/) {
            my $programs = lc $1;
            if ($programs ne 'true' && $programs ne 'false') {
                warn "$dir/$file: programs should be set to true or false\n";
            } elsif ($programs eq 'true') {
                push (@{ $$config{progdirs} }, $dir);
            }
        } else {
            warn "$dir/$file: ignoring unknown line: $_\n";
        }
    }
}

# Write out include directives for a list of files.
sub write_includes {
    my ($fh, $config) = @_;
    my $method;
    for $method (sort keys %{ $$config{method} }) {
        my $path = $$config{method}{$method};
        print $fh qq(\#include "$path/$method.h"\n);
    }
}

# Write out the method struct.
sub write_methods {
    my ($fh, $config, $prefix, @funcs) = @_;
    my ($notfirst, $method);
    for $method (sort keys %{ $$config{method} }) {
        print $fh "\n},\n" if $notfirst;
        print $fh qq(\{\n    "$method");
        print $fh ', ', $prefix, '_', uc ($method) if $prefix;
        for (@funcs) {
            print $fh ",\n    ${method}_$_";
        }
        $notfirst++;
    }
    print $fh "\n}\n};\n\n";
}

# Write out the constant defines for methods.
sub write_constants {
    my ($fh, $config, $prefix) = @_;
    my $method;
    for $method (sort keys %{ $$config{method} }) {
        printf $fh "#define ${prefix}_%-30s%d\n", uc ($method),
            $$config{number}{$$config{method}{$method}};
    }
}

# Write out methods.c and methods.h for the interface to the storage
# methods.
sub write_storage {
    my $storage = shift;
    open (DEF, '> methods.c.new') or die "Can't create methods.c.new: $!\n";
    print DEF unquote (<<'EOE');
:       /* This file is automatically generated by buildconfig. */
:
:       #include "interface.h"
:       #include "methods.h"
EOE
    my $method;
    write_includes (\*DEF, $storage);
    print DEF "\nSTORAGE_METHOD storage_methods[",
        scalar (keys %{ $$storage{method} }), "] = {\n";
    write_methods (\*DEF, $storage, 'TOKEN', @STORAGE);
    close DEF;
    rename ('methods.c.new', 'methods.c');

    open (H, '> methods.h.new') or die "Can't open methods.h.new: $!\n";
    print H unquote (<<'EOE');
:       /* This file is automatically generated by buildconfig */
:
:       #ifndef METHODS_H
:       #define METHODS_H 1
:
:       #include "interface.h"
:
EOE
    print H '#define NUM_STORAGE_METHODS ',
        scalar (keys %{ $$storage{method} }), "\n\n";
    write_constants (\*H, $storage, 'TOKEN');
    print H unquote (<<'EOE');
:
:       extern STORAGE_METHOD storage_methods[NUM_STORAGE_METHODS];
:
:       #endif /* METHODS_H */
EOE
    close H;
    rename ('methods.h.new', 'methods.h');
}

# Write out ovmethods.c and ovmethods.h for the interface to the overview
# methods.
sub write_overview {
    my $overview = shift;
    open (DEF, '> ovmethods.c.new')
        or die "Can't create ovmethods.c.new: $!\n";
    print DEF unquote (<<'EOE');
:       /* This file is automatically generated by buildconfig. */
:
:       #include "ovinterface.h"
EOE
    write_includes (\*DEF, $overview);
    print DEF "\nOV_METHOD ov_methods[",
        scalar (keys %{ $$overview{method} }), "] = {\n";
    write_methods (\*DEF, $overview, undef, @OVERVIEW);
    close DEF;
    rename ('ovmethods.c.new', 'ovmethods.c');

    open (H, '> ovmethods.h.new') or die "Can't open ovmethods.h.new: $!\n";
    print H unquote (<<'EOE');
:       /* This file is automatically generated by buildconfig */
:
:       #ifndef OVMETHODS_H
:       #define OVMETHODS_H 1
:
:       #include "ovinterface.h"
:
EOE
    print H '#define NUM_OV_METHODS ',
        scalar (keys %{ $$overview{method} }), "\n";
    print H unquote (<<'EOE');
:
:       extern OV_METHOD ov_methods[NUM_OV_METHODS];
:
:       #endif /* OVMETHODS_H */
EOE
    close H;
    rename ('ovmethods.h.new', 'ovmethods.h');
}

# Write out the makefile fragment for overview and storage methods.
sub write_makefile {
    my ($dirs, $objects, $progdirs) = @_;
    open (MAKE, '> Make.methods.new')
        or die "Can't create Make.methods.new: $!\n";
    print MAKE "# This file is automatically generated by buildconfig\n\n";
    print MAKE "SUBDIRS = @$dirs\n";
    print MAKE "PROGDIRS = @$progdirs\n";
    print MAKE "METHOD_OBJECTS = @$objects\n";
    print MAKE unquote (<<'EOE');
:
:       # The following dependencies ensure that all objects that are part of
:       # methods are built via recursive make rather than using the implicit
:       # make rules for building .c files from .o files.
EOE
    my %methods;
    for (@$objects) {
        my $dir = $_;
        $dir =~ s%/+.*%%;
        $methods{$dir} ||= [];
        push (@{ $methods{$dir} }, $_);
    }
    for (sort keys %methods) {
        print MAKE "@{ $methods{$_} }:\n\tcd $_ && make objects\n\n";
    }
    close MAKE;
    rename ('Make.methods.new', 'Make.methods');
}

my ($dir, %storage, %overview);
if (!-d 'cnfs') {
    if (-d 'storage/cnfs') {
        chdir 'storage' or die "Can't chdir to storage: $!\n";
    } else {
        die "Can't find storage directory (looking for storage/cnfs)\n";
    }
}
opendir (D, ".") or die "Can't open current directory: $!\n";
my @dirs = sort readdir D;
for $dir (@dirs) {
    if (-e "$dir/method.config") {
        parse_config ($dir, 'method.config', \%storage);
    }
    if (-e "$dir/ovmethod.config") {
        parse_config ($dir, 'ovmethod.config', \%overview);
    }
}
write_storage (\%storage);
write_overview (\%overview);
@dirs = (sort values %{ $storage{method} },
         sort values %{ $overview{method} });
my @objs = (sort @{ $storage{objects} }, sort @{ $overview{objects} });
my @progdirs = sort (@{ $storage{progdirs} }, @{ $overview{progdirs} });
write_makefile (\@dirs, \@objs, \@progdirs);
