#!@_PATH_PERL@
#
# news to mail channel backend
#
# INN gives us
#	@token@ addrs
# for each article that needs to be mailed.  We invoke sm on the
# localhost to get the actual article and stuff
# it down sendmail's throat.
# 
# This program expect to find a file that maps listname to listaddrs,
#	@prefix@/etc/news2mail.cf
# which must contain address mapping pairs such as
#
#	big-red-ants@ucsd.edu	big-red-ants-digest@ucsd.edu		
#
# where the first token is the name fed to us from INN, and which is
# also placed in the To: header of the outgoing mail.  It's probably
# the subscriber's list submittal address so that replies go to the
# right place.  The second token is the actual address sendmail ships
# the article to.
#
# In the INN newsfeeds file, you need to have a channel feed:
#	n2m!:!*:Tc,Ac,Wn*:@prefix@/bin/news2mail
# and a site for each of the various mailing lists you're feeding,
# such as
#	big-red-ants@ucsd.edu:rec.pets.redants.*:Tm:n2m!
#
# Error handling is nearly nonexistent.
#
#	- Brian Kantor, UCSD Aug 1998

require 5.002;

use FileHandle;
use Sys::Syslog;

require "@LIBDIR@/innshellvars.pl";
my $cfFile = $inn::pathetc . "/news2mail.cf" ;
my $sendmail = $inn::mta ;
my $sm = $inn::pathbin . "/sm" ;

#
# the syslog calls are here but don't work on my system
#
openlog('news2mail', 'pid', 'mail');

syslog('info', 'begin');

#
# load the list names and their mail addresses from cf file
# #comments and blank lines are ignored
#
unless (open CF, "< $cfFile") {
		syslog('notice', 'CF open failed %m');
		die "bad CF";
		}

while ( $line = <CF> ) {
	next if ($line =~ /^#|^\s+/);
	( $ln, $ma ) = split /\s+/, $line;
	$maddr{ $ln } = $ma;
	}
close CF;

#
# for each incoming line from the INN channel
#
while ( <STDIN> ) {
	chomp;

	syslog('info', $_);

	($token, $lnames) = split /\s+/, $_, 2;

	$addrs = "";
	$cnt = 0;

	for $ln ( split /\s+/, $lnames ) {
		if ( $maddr{ $ln } ) {
			$cnt++;
			}
		$addrs = join ' ', $addrs, $maddr{ $ln };
		}

	if ($cnt > 0) {
		mailto($token, $lnames, $addrs);
		}
	else {
		syslog('notice', 'unknown listname %s', $_);
		}
	}

syslog ("info", "end") ;

exit 0;

use strict;

sub mailto {
	my($t, $l, $a) = @_ ;

	my ($smgrpid, $smgr);
	my ($smid, $smpid, $d, $ih, $line, $reply, $sendmail);


	$sendmail = "|" . $inn::mta ;
	$sendmail =~ s!%s!! ;
	$sendmail .= " -ee '-f<news>' -odq " . $a;
#	$sendmail = "|/usr/local/bin/debug -oi -ee '-f<news>' -odq " . $a;

	syslog('info', $sendmail);

	unless ($smpid = (open SM, $sendmail)) {
		syslog('notice', '%s failed!', $sendmail);
		die "bad $sendmail";
		}

	if ($inn::storageapi eq "true") {
	    $smgr = "$sm -q $t |";

	    unless ($smgrpid = (open SMGR, $smgr)) {
		syslog('notice', '%s failed!', $smgr);
		die "bad $smgr";
	    }
	} else {
	    my $path = $inn::patharticles . "/" . $t ;
	    unless (open SMGR, "<$path") {
		syslog('notice', "no such path: $path");
		return ;
	    }
		
	}

	# header
	$ih = 1;
	while ( $ih == 1 && defined($line = <SMGR>) ) {
		chop $line;

		# empty line signals end of header
		if ($line eq "") {
			print SM "To: $l\n\n";
			$ih = 0;
			next;	
			}

		#
		# skip unnecessary headers
		#
		next if ($line =~ /^NNTP-Posting-Date:/i);
		next if ($line =~ /^NNTP-Posting-Host:/i);
		next if ($line =~ /^Xref:/i);
		next if ($line =~ /^Path:/i);

		#
		# convert Newsgroups header into X-Newsgroups
		#
		$line =~ s/^Newsgroups:/X-Newsgroups:/i;
		print SM "$line\n";
		}

	# body
	while ( $line = <SMGR> ) {
		print SM $line;
	}

out:
	close(SMGR);
	close(SM);
	}
