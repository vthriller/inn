#! /usr/bin/perl

require 5.003;
use File::Basename;

if (scalar(@ARGV) <= 0) {
    printf STDERR "No history methods are available\n";
    exit(1);
}

$objects = "";
foreach $file (@ARGV) {
    open(CFG, $file) || die "$!";
    $dir = dirname $file;
    while (<CFG>) {
	chomp;

	s/^\s+//;
	s/\s+$//;
	if (/^name\s*=\s*(\S+)/) {
	    $method = $1;
	    if (defined($methods{$method})) {
		print STDERR "$method has already been defined\n";
		exit(1);
	    } else {
		$methods{$method} = $file;
	    }
	}
	if (/^number\s*=\s*(\d+)/) {
	    $number = $1;
	    if (defined($number{$number})) {
		print STDERR "Method number $number was already allocated in $number{$number}\n";
		exit(1);
	    }
	    $number{$number} = $file;
	    $methodnum{$file} = $number;
	    next;
	}
	if (/^modules\s*=\s*(.*)/) {
	    (@objs) = split /\s+/,$1;
	    foreach $i (@objs) {
		$objects .= " $dir/$i";
	    }
	}
    }
    close(CFG);
}

open(DEF, ">hismethods.c.new");
print DEF "/* This file is automatically generated by hisbuildconfig */\n\n";
print DEF "#include \"config.h\"\n";
print DEF "#include \"clibrary.h\"\n";
print DEF "#include \"hisinterface.h\"\n";

foreach $method (keys %methods) {
    $path = $methods{$method};
    $path =~ s/\.\///;
    $path =~ s/hismethod\.config//g;
    print DEF "#include \"$path$method", ".h\"\n";
}
print DEF "\n";

print DEF "HIS_METHOD his_methods[", scalar(keys(%methods)), "] = {\n";

foreach $method (keys %methods) {
    print "History method '$method' configured\n";
    if ($first) {
	print DEF " },\n";
    }
    print DEF "\t{ \"$method\", \n\t  ";
    print DEF $method, "_open, ", $method, "_close, \n\t  ", $method, "_sync, ";
    print DEF $method, "_lookup, \n\t  ", $method, "_check, ", $method, "_write, \n\t  ";
    print DEF $method, "_replace, ", $method, "_expire, \n\t  ", $method, "_walk, ";
    print DEF $method, "_error, \n\t  ", $method, "_remember";
    $first++;
}

print DEF " }\n};\n\n";
close(DEF);
`cmp -s hismethods.c hismethods.c.new`;
if ($? == 0) { unlink("hismethods.c.new"); }
else { unlink("hismethods.c"); rename("hismethods.c.new","hismethods.c"); }

open(H, ">hismethods.h.new");
print H "/* This file is automatically generated by buildconfig */\n\n";
print H "#ifndef __HISMETHODS_H__\n";
print H "#define __HISMETHODS_H__\n\n";
print H "#include <hisinterface.h>\n\n";
print H "#define NUM_HIS_METHODS\t", scalar(keys(%methods)), "\n\n";
print H "extern HIS_METHOD his_methods[NUM_HIS_METHODS];\n\n";
print H "#endif /* __HISMETHODS_H__ */\n";
close(H);
`cmp -s hismethods.h hismethods.h.new`;
if ($? == 0) { unlink("hismethods.h.new"); }
else { unlink("hismethods.h"); rename("hismethods.h.new","hismethods.h");
}

open(LIST, ">Make.hismethods.new");
print LIST "# This file is automatically generated by hisbuildconfig\n\n";
print LIST "HISSUBDIR = ";
foreach $method (keys %methods) {
    $path = $methods{$method};
    $path =~ s/\.\///;
    $path =~ s/\/hismethod\.config//;
    print LIST "$path ";
}
print LIST "\n";
print LIST "HIS_OBJECTS = $objects\n";
$objects =~ s/\.o\b/.lo/g;
print LIST "LHIS_OBJECTS = $objects\n";
close(LIST);
`cmp -s Make.hismethods Make.hismethods.new`;
if ($? == 0) { unlink("Make.hismethods.new"); }
else { unlink("Make.hismethods"); rename("Make.hismethods.new","Make.hismethods"); }
