#! /usr/bin/perl

##  $Id$
##
##  Generate linkage code and makefiles for storage and overview methods.
##
##  Goes through all subdirectories of the current directory and finds
##  directories that history methods or overview methods.  Builds
##  hismethods.[ch] as well as makefile stubs.

require 5.003;

use strict;
use vars qw(@HISTORY);

# History API functions.
@HISTORY = qw(open close sync lookup check write replace expire walk remember
              ctl);

# Used to make heredocs more readable.
sub unquote { my ($string) = @_; $string =~ s/^:( {0,7}|\t)//gm; $string }

# Parse a hismethod.config file for a history method, putting information
# about that history method into the given hash ref.
sub parse_config {
    my ($dir, $file, $config) = @_;
    $$config{objects} ||= [];
    $$config{progdirs} ||= [];
    local $_;
    open (CONFIG, "$dir/$file") or die "Can't open $dir/$file: $!\n";
    while (<CONFIG>) {
        s/^\s+//;
        s/\s+$//;
        if (/^name\s*=\s*(\S+)$/) {
            my $method = $1;
            die "$dir/$file: $method has already been defined\n"
                if (defined $$config{method}{$method});
            $$config{method}{$method} = $dir;
        } elsif (/^number\s*=\s*(\d+)$/) {
            my $number = $1;
            if (defined $$config{number}{$number}) {
                die "$dir/$file: method number $number was already "
                    . "allocated\n";
            }
            $$config{number}{$dir} = $number;
        } elsif (/^modules\s*=\s*(.*)/) {
            my $objects = $1;
            my @objects = split (' ', $objects);
            push (@{ $$config{objects} }, map { "$dir/$_" } @objects);
        } elsif (/^programs\s*=\s*(.*)/) {
            my $programs = lc $1;
            if ($programs ne 'true' && $programs ne 'false') {
                warn "$dir/$file: programs should be set to true or false\n";
            } elsif ($programs eq 'true') {
                push (@{ $$config{progdirs} }, $dir);
            }
        } else {
            warn "$dir/$file: ignoring unknown line: $_\n";
        }
    }
}

# Write out include directives for a list of files.
sub write_includes {
    my ($fh, $config) = @_;
    my $method;
    for $method (sort keys %{ $$config{method} }) {
        my $path = $$config{method}{$method};
        print $fh qq(\#include "$path/$method.h"\n);
    }
}

# Write out the method struct.
sub write_methods {
    my ($fh, $config, $prefix, @funcs) = @_;
    my ($notfirst, $method);
    for $method (sort keys %{ $$config{method} }) {
        print $fh "\n},\n" if $notfirst;
        print $fh qq(\{\n    "$method");
        print $fh ', ', $prefix, '_', uc ($method) if $prefix;
        for (@funcs) {
            print $fh ",\n    ${method}_$_";
        }
        $notfirst++;
    }
    print $fh "\n}\n};\n\n";
}

# Write out hismethods.c and hismethods.h for the interface to the history
# methods.
sub write_history {
    my $history = shift;
    open (DEF, '> hismethods.c.new')
        or die "Can't create hismethods.c.new: $!\n";
    print DEF unquote (<<'EOE');
:       /* This file is automatically generated by buildconfig. */
:
:       #include "hisinterface.h"
:       #include "hismethods.h"
EOE
    my $method;
    write_includes (\*DEF, $history);
    print DEF "\nHIS_METHOD his_methods[",
        scalar (keys %{ $$history{method} }), "] = {\n";
    write_methods (\*DEF, $history, undef, @HISTORY);
    close DEF;
    rename ('hismethods.c.new', 'hismethods.c');

    open (H, '> hismethods.h.new') or die "Can't open hismethods.h.new: $!\n";
    print H unquote (<<'EOE');
:       /* This file is automatically generated by buildconfig */
:
:       #ifndef HISMETHODS_H
:       #define HISMETHODS_H 1
:
:       #include "hisinterface.h"
:
EOE
    print H '#define NUM_HIS_METHODS ',
        scalar (keys %{ $$history{method} }), "\n";
    print H unquote (<<'EOE');
:
:       extern HIS_METHOD his_methods[NUM_HIS_METHODS];
:
:       #endif /* HISMETHODS_H */
EOE
    close H;
    rename ('hismethods.h.new', 'hismethods.h');
}

# Write out the makefile fragment for history methods.
sub write_makefile {
    my ($dirs, $objects, $progdirs) = @_;
    open (MAKE, '> Make.methods.new')
        or die "Can't create Make.methods.new: $!\n";
    print MAKE "# This file is automatically generated by buildconfig\n\n";
    print MAKE "SUBDIRS = @$dirs\n";
    print MAKE "PROGDIRS = @$progdirs\n";
    print MAKE "METHOD_OBJECTS = @$objects\n";
    print MAKE unquote (<<'EOE');
:
:       # The following dependencies ensure that all objects that are part of
:       # methods are built via recursive make rather than using the implicit
:       # make rules for building .c files from .o files.
EOE
    my %methods;
    for (@$objects) {
        my $dir = $_;
        $dir =~ s%/+.*%%;
        $methods{$dir} ||= [];
        push (@{ $methods{$dir} }, $_);
    }
    for (sort keys %methods) {
        print MAKE "@{ $methods{$_} }:\n\tcd $_ && \$(MAKE) objects\n\n";
    }
    close MAKE;
    rename ('Make.methods.new', 'Make.methods');
}

my ($dir, %history);
if (!-d 'hisv6') {
    if (-d 'history/cnfs') {
        chdir 'history' or die "Can't chdir to history: $!\n";
    } else {
        die "Can't find history directory (looking for history/hisv6)\n";
    }
}
opendir (D, ".") or die "Can't open current directory: $!\n";
my @dirs = sort readdir D;
for $dir (@dirs) {
    if (-e "$dir/hismethod.config") {
        parse_config ($dir, 'hismethod.config', \%history);
    }
}
write_history (\%history);
@dirs = sort values %{ $history{method} };
my @objs = sort @{ $history{objects} };
my @progdirs = sort @{ $history{progdirs} };
write_makefile (\@dirs, \@objs, \@progdirs);
