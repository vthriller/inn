#! /usr/bin/perl
# fixscript will replace this line with require innshellvars.pl

# news to mail channel backend
#
# INN gives us
#	@token@ addrs
# for each article that needs to be mailed.  We invoke sm on the
# localhost to get the actual article and stuff
# it down sendmail's throat.
# 
# This program expect to find a file that maps listname to listaddrs,
#	@prefix@/etc/news2mail.cf
# which must contain address mapping pairs such as
#
#	big-red-ants@ucsd.edu	big-red-ants-digest@ucsd.edu		
#
# where the first token is the name fed to us from INN, and which is
# also placed in the To: header of the outgoing mail.  It's probably
# the subscriber's list submittal address so that replies go to the
# right place.  The second token is the actual address sendmail ships
# the article to.
#
# In the INN newsfeeds file, you need to have a channel feed:
#	n2m!:!*:Tc,Ac,Wn*:@prefix@/bin/news2mail
# and a site for each of the various mailing lists you're feeding,
# such as
#	big-red-ants@ucsd.edu:rec.pets.redants.*:Tm:n2m!
#
# Error handling is nearly nonexistent.
#
#	- Brian Kantor, UCSD Aug 1998

require 5.002;

use FileHandle;
use Sys::Syslog;
use strict;

my $cfFile = $inn::pathetc . "/news2mail.cf" ;
my $sendmail = $inn::mta ;
my $sm = $inn::pathbin . "/sm" ;
my %maddr = ();

#
# the syslog calls are here but don't work on my system
#
openlog('news2mail', 'pid', 'mail');

syslog('info', 'begin');

#
# load the list names and their mail addresses from cf file
# #comments and blank lines are ignored
#
unless (open CF, "< $cfFile") {
		syslog('notice', 'CF open failed %m');
		die "bad CF";
		}

while ( <CF> ) {
	next if /^#|^\s+$/;
	my ( $ln, $ma ) = split /\s+/;
	$maddr{ $ln } = $ma;
	}
close CF;

#
# for each incoming line from the INN channel
#
while ( <STDIN> ) {
	chomp;

	syslog('info', $_);

	my ($token, $lnames) = split /\s+/, $_, 2;
	my @addrs = split /\s+/, $lnames;

	my @good = grep {  defined $maddr{$_} } @addrs;
	my @bad  = grep { !defined $maddr{$_} } @addrs;

	if (! @good) {
		syslog('notice', "unknown listname $_");
		next;
		}

	if (@bad) {
		syslog('info', 'skipping unknown lists: ', join(' ', @bad));
		}
	mailto($token, $lnames, @maddr{@good});
	}

syslog ("info", "end") ;

exit 0;

sub mailto {
	my($t, $l, @a) = @_ ;

	my $sendmail = $inn::mta ;
	$sendmail =~ s!\s*%s!! ;
	my @command = (split (' ', $sendmail), '-ee', '-f<news>', '-odq', @a);
#	@command[0] = '/usr/local/bin/debug';

	syslog('info', join(' ', @command));

	unless (open(SM, '|-', @command)) {
		syslog('notice', join(' ', '|', @command), 'failed!');
		die "bad $sendmail";
		}

	my $smgr = "$sm -q $t |";

	unless (open(SMGR, $smgr)) {
	    syslog('notice', "$smgr failed!");
	    die "bad $smgr";
	}

	# header
	while ( <SMGR> ) {
		chomp;

		# empty line signals end of header
		if ( /^$/ ) {
			print SM "To: $l\n\n";
			last;	
			}

		#
		# skip unnecessary headers
		#
		next if /^NNTP-Posting-Date:/i;
		next if /^NNTP-Posting-Host:/i;
		next if /^X-Trace:/i;
		next if /^Xref:/i;
		next if /^Path:/i;

		#
		# convert Newsgroups header into X-Newsgroups
		#
		s/^Newsgroups:/X-Newsgroups:/i;

		print SM "$_\n";
		}

	# body
	while ( <SMGR> ) {
		print SM $_;
	}

	close(SMGR);
	close(SM);
	}
